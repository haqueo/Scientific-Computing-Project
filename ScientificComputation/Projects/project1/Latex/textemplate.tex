\documentclass[paper=a4, fontsize=12pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % use 8-bit encoding that has 256 glyphs
\usepackage{fourier}     % use the Adobe Utopia font for the document
                         % (comment this line to return to the LaTeX default)
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % math packages
\usepackage{subeqnarray}

\usepackage{lipsum} % used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{bold-extra}

\usepackage{listings}
\usepackage[utf8]{inputenc}

% default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{11} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{11}  % for normal

% custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{lightblue}{rgb}{0.95,0.95,1}
\definecolor{lightgrey}{rgb}{0.6,0.6,0.6}
\usepackage{listings}

% use graphics packages
\usepackage{graphicx}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{calc}
\usetikzlibrary{patterns,fadings}

\graphicspath{ {images/} }

% python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
backgroundcolor=\color{lightblue},
basicstyle=\ttm,
    % add keywords here
keywordstyle=\ttb\color{deepblue},
emph={while,for,if,elif,else,def,as,shape,conj,dot,copy,flatten,eye,zeros,ones,hstack,vstack,real,imag,conjugate,sin,cos,exp,append,insert,index,__main__}, % custom highlighting
%emphstyle=\ttb\color{deepred},     % custom highlighting style
emphstyle=\ttb\color{deepblue},     % custom highlighting style
stringstyle=\color{deepgreen},
commentstyle=\color{lightgrey},
frame=tb,                         % any extra options here
numbers=left,
showstringspaces=false            %
}}

% python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


\usepackage{sectsty}        % allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape}      % make all sections centered
                                                      % the default font and small caps

\usepackage{fancyhdr}        % custom headers and footers
\pagestyle{fancyplain}       % makes all pages in the document conform to
                             % the custom headers and footers
\fancyhead{}                 % no page header - if you want one, create it in
                             % the same way as the footers below
\fancyfoot[L]{}              % empty left footer
\fancyfoot[C]{}              % empty center footer
\fancyfoot[R]{\thepage}      % page numbering for right footer
\renewcommand{\headrulewidth}{0pt}     % remove header underlines
\renewcommand{\footrulewidth}{0pt}     % remove footer underlines
\setlength{\headheight}{13.6pt}        % customize the height of the header

\numberwithin{equation}{section}       % number equations within sections
                                       % (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section}         % number figures within sections
                                       % (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section}          % number tables within sections
                                       % (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt}         % removes all indentation from paragraphs
                                  % comment this line for an assignment with lots of text

%--------------------------
%	TITLE SECTION
%--------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % create horizontal rule command
                                                % with 1 argument of height

\title{
\normalfont \normalsize
\textsc{Imperial College London, Department of Mathematics} \\ [25pt]
\horrule{0.5pt} \\[0.4cm]                      % thin top horizontal rule
\huge Scientific Computing (M3SC) Project 1 \\           % the assignment title
\horrule{2pt} \\[0.5cm]                        % thick bottom horizontal rule
}

\author{Omar Haque}
\date{\normalsize\today}

\begin{document}
%\ttfamily
%\fontseries{b}\selectfont

\maketitle

\section{Main Solution}

The code in \textit{solution.py} contains the main program which carries out the process outlined by the question, i.e modelling the process of the cars moving across the city of Rome using the rules described. I have added scripts \textit{to be added} and \textit{to be added} to help answer the related questions at the end of the project.
\newline

Below are the imports used by the main program.

\begin{python}
# Imports
import numpy as np
import csv
import sys
import math as ma

# This import is needed for the last question
from solution_accident_occurs import max_index_tracker_no30
\end{python}

the variable \textit{max\_index\_tracker\_no30} is imported from another python script, 
\newline
\textit{solution\_accident\_occurs.py} in order to answer one of the questions. This will be discussed in detail later.
\leavevmode
\newline

Below are the functions required by the program. The docstring's explain their use.

\leavevmode
\newline

\begin{python}
# ------------------------------------------------------------------
# ------------------    FUNCTIONS USED     -------------------------
# ------------------------------------------------------------------

def calcWei(RX, RY, RA, RB, RV):
    """
    This function is taken from Tutorials. It calculates the weight matrix
    given information about each node in the system.
    :param RX: The x coordinates of each node in the system
    :param RY: The y coordinates of each node in the system
    :param RA: the connectivity of each node in the system
    :param RB: the connectivity of each node in the system
    :param RV: the speed limits across each edge in the system
    :return: usable weight matrix
    """

    n = len(RX)
    wei = np.zeros((n, n), dtype=float)
    m = len(RA)
    for i in range(m):
        xa = RX[RA[i] - 1]
        ya = RY[RA[i] - 1]
        xb = RX[RB[i] - 1]
        yb = RY[RB[i] - 1]
        dd = ma.sqrt((xb - xa) ** 2 + (yb - ya) ** 2)
        tt = dd / RV[i]
        wei[RA[i] - 1, RB[i] - 1] = tt
    return wei
    
def Dijkst(ist, isp, wei):
    """
    This Dijkstra's algorithm implementation is taken from tutorials.
    
    :param ist: the index of the starting node
    :param isp: the index of the node to reach
    :param wei: the assosciated weight matrix
    :return: 
    """

    # exception handling (start = stop)
    if ist == isp:
        shpath = [ist]
        return shpath

    # initialization
    N = len(wei)
    Inf = sys.maxint
    UnVisited = np.ones(N, int)
    cost = np.ones(N) * 1.e6
    par = -np.ones(N, int) * Inf

    # set the source point and get its (unvisited) neighbors
    jj = ist
    cost[jj] = 0
    UnVisited[jj] = 0
    tmp = UnVisited * wei[jj, :]
    ineigh = np.array(tmp.nonzero()).flatten()
    L = np.array(UnVisited.nonzero()).flatten().size

    # start Dijkstra algorithm
    while (L != 0):
        # step 1: update cost of unvisited neighbors,
        #         compare and (maybe) update
        for k in ineigh:
            newcost = cost[jj] + wei[jj, k]
            if (newcost < cost[k]):
                cost[k] = newcost
                par[k] = jj

        # step 2: determine minimum-cost point among UnVisited
        #         vertices and make this point the new point
        icnsdr = np.array(UnVisited.nonzero()).flatten()
        cmin, icmin = cost[icnsdr].min(0), cost[icnsdr].argmin(0)
        jj = icnsdr[icmin]

        # step 3: update "visited"-status and determine neighbors of new point
        UnVisited[jj] = 0
        tmp = UnVisited * wei[jj, :]
        ineigh = np.array(tmp.nonzero()).flatten()
        L = np.array(UnVisited.nonzero()).flatten().size

    # determine the shortest path
    shpath = [isp]
    while par[isp] != ist:
        shpath.append(par[isp])
        isp = par[isp]
    shpath.append(ist)

    return shpath[::-1]

def next_node(path):
    """ Returns the next index (after the node itself) in the path.
        If the path contains only one node, returns the node itself.
    """
    if len(path) == 1:
        return path[0]
    else:
        return path[1]


def update_weight_matrix(epsilon, c, original_weight_matrix, noNodes=58):
    """
    This function updates the weight matrix according to step 5 of the
    Project. Note the added fix - the weight matrix is not changed if
    the original entry was 0.



    :param epsilon: given in question
    :param c: the vector containing number of cars at each node
    :param original_weight_matrix: the weight matrix given by RomeEdges
    :param noNodes: number of nodes in the system
    :return: the updated weight matrix
    """
    new_weight_matrix = np.zeros((noNodes, noNodes))
    for i in range(noNodes):
        for j in range(noNodes):
            if original_weight_matrix[i, j] != float(0):
                new_weight_matrix[i, j] = original_weight_matrix[i, j] + \
                                          (epsilon * (float(c[i]) +
                                                      float(c[j]))) / float(2)
    return new_weight_matrix


def extract_data():
    """
    This function opens the RomeVertices and RomeEdges files, and creates
    global variables RomeX, RomeY, RomeA, RomeB and RomeV. These are variables
    used to create the original weight matrix.

    """
    global RomeX, RomeY, RomeA, RomeB, RomeV
    RomeX = np.empty(0, dtype=float)
    RomeY = np.empty(0, dtype=float)
    with open('./data/RomeVertices', 'r') as file:
        AAA = csv.reader(file)
        for row in AAA:
            RomeX = np.concatenate((RomeX, [float(row[1])]))
            RomeY = np.concatenate((RomeY, [float(row[2])]))
    file.close()
    RomeA = np.empty(0, dtype=int)
    RomeB = np.empty(0, dtype=int)
    RomeV = np.empty(0, dtype=float)
    with open('./data/RomeEdges2', 'r') as file:
        AAA = csv.reader(file)
        for row in AAA:
            RomeA = np.concatenate((RomeA, [int(row[0])]))
            RomeB = np.concatenate((RomeB, [int(row[1])]))
            RomeV = np.concatenate((RomeV, [float(row[2])]))
    file.close()
\end{python}

Now using these functions, we can execute the main program.

\begin{python}
    # --------------------------------------------------------------
    # ------------------    Main program     -----------------------
    # --------------------------------------------------------------


if __name__ == '__main__':

    # Import the rome edges file
    extract_data()

    # Use the calcWei function from tutorials, along with the data set given
    # to calculate the weight matrix. Also create a copy which is the
    # temporary weight matrix.
    weight_matrix = misc.calcWei(RomeX, RomeY, RomeA, RomeB, RomeV)
    temp_wei = weight_matrix.copy()

    # Initialise minutes and number of nodes
    minutes = 200
    total_nodes = weight_matrix.shape[0]

    # Need a vector carNumbers which stores the number of cars at each vertex
    # in the graph.
    cars_at_node = np.zeros(total_nodes, dtype=int)
    cars_at_node_updated = cars_at_node.copy()  # cars_at_node updated is similar
    max_cars_at_node = cars_at_node.copy()  # max_cars_at_node is similar

    # To find the edges utilised, we need a 58x58 matrix of
    # False's. We will set each element to True if we move
    # cars from node i to node j.
    edge_utilised = np.zeros((total_nodes, total_nodes), dtype=bool)

    # Iterate through the 200 minutes
    for i in range(minutes):

        # Apply Dijkstra's algorithm to find the fastest path to node 52 in
        # the system. Then use next_node to find the next node in the given
        # path. (step 1)
        next_nodes = [next_node(Dijkst(node, 51, temp_wei))
                      for node in range(total_nodes)]

        # Move all cars as in steps 2,3. Iterate through every node in the
        # system to do this.
        for j_node in range(total_nodes):

            if j_node == 51:
                # We remove 40% of cars from node 52.
                cars_at_node_updated[51] += int(round(cars_at_node[51] * 0.6))
            else:

                # Initialise the number of cars at node j_node.
                number_of_cars = cars_at_node[j_node]

                # Initialise the next node to move to.
                node_to_move_to = next_nodes[j_node]

                # 70% of cars will move. to keep the total conserved, 
                # the amount staying is just 
                # number_of_cars - amount_moving
                amount_moving = int(round(0.7 * number_of_cars))
                amount_staying = number_of_cars - amount_moving

                # We now update cars_at_node.
                cars_at_node_updated[j_node] += amount_staying
                cars_at_node_updated[node_to_move_to] += amount_moving

                if amount_moving > 0:
                    # Update edges_utilised matrix
                    edge_utilised[j_node, node_to_move_to] = True

        # Now all cars have moved where they need to, we set cars_at_node
        # to this updated vector, and empty the updated vector for the next
        # iteration.
        cars_at_node = cars_at_node_updated.copy()
        cars_at_node_updated = np.zeros(total_nodes, dtype=int)

        # For the first 180 minutes, 20 cars are injected into node 13.
        if i <= 179:
            cars_at_node[12] += 20

        # The temporary weight matrix is updated.
        temp_wei = update_weight_matrix(0.01, cars_at_node, weight_matrix)

        # We have finished an iteration.

       # Now we calculate the maximum number of cars at each node in the system.
        max_cars_at_node = [max(cars_at_node[node], max_cars_at_node[node]) 
                            for node in range(total_nodes)]
\end{python}

\section{Questions}

\textbf{Determine for each node the maximum load (maximum number of cars) over the 200 iterations.}
\newline

As we have already incorporated the calculation of maximums in the loop, this is easy:

\begin{python}
max_index_tracker = [[node+1, max_cars_at_node[node]]
                         for node in range(total_nodes)]
\end{python}

Thus the i'th element of this array gives [node i, maximum number of cars of node i over the 200 iterations ]. The code to print is below along with the output.

\begin{python}
print('max_index_tracker is')
print(max_index_tracker[0:10])
print(max_index_tracker[10:20])
print(max_index_tracker[20:30])
print(max_index_tracker[30:40])
print(max_index_tracker[40:50])
print(max_index_tracker[50:(len(max_index_tracker)+1)])
\end{python}

\includegraphics[scale=0.7]{max_index.png}
\leavevmode
\newline

\textbf{Which are the five most congested nodes?} \newline
Given this array \textit{max\_index\_tracker}, we can simply sort by the second argument to find the top five most congested nodes
\begin{python}
top_five = sorted(max_index_tracker,
                      key=lambda node_and_max: -1 * node_and_max[1])[:5]
print('the five most congested nodes are')
print(top_five)
\end{python}
\includegraphics{top_five.png}

In other words, the top five most congested nodes (from highest to lowest) is node 52 with 63 cars, node 25 with 40 cars, node 21 with 38 cars, node 30 with 32 cars and node 43 with 31 cars.
\newline


\textbf{Which edges are not utilized at all? Why?}
\leavevmode
\newline

In the main program we defined a 58x58 boolean matrix of False's, where throughout the process if cars moved from index i to index j, we made the [i,j] element of the matrix True.
\leavevmode
\newline

Thus, we have a matrix where indices (corresponding to edges) are \textit{True} if they are traversed by some amount of cars ($ > 0$) in the 200 minute process.
\leavevmode
\newline

All that is left to do is count the number of False's, making sure that we don't count a False if the edge couldn't be traversed to begin with (in the original weight matrix). This corresponds to an element of the original weight matrix being 0.

\begin{python}
# create a boolean matrix that corresponds to the condition
# described above
non_utilised_edges_matrix = (weight_matrix != float(0)) \
                                & (np.logical_not(edge_utilised))
                                
non_utilised_edges = [[i+1, j+1] for i in range(total_nodes)
                          for j in range(total_nodes)
                          if non_utilised_edges_matrix[i, j]]

\end{python}

So an element $[l,m]$ belonging to this vector \textit{non\_utilised\_edges} implies that the edge $l \to m$ is not utilised.

The code to print this and the output is below.

\begin{python}
print('the non utilised edges are')
print(non_utilised_edges[0:10])
print(non_utilised_edges[10:20])
print(non_utilised_edges[20:30])
print(non_utilised_edges[30:40])
print(non_utilised_edges[40:50])
print(non_utilised_edges[50:60])
print(non_utilised_edges[60:(len(non_utilised_edges)+1)])
\end{python}

\includegraphics[scale=0.65]{non_utilised_edges}

Now I answer \textit{why} these edges aren't utilised. 

Firstly we note that from the first question where we found the maximum load for all cars over the 200 iterations, it is clear that nodes with maximum load 0 (i.e. node 3, 5, 8 etc) will always appear on this list since they were never visited. However, the real question is \textit{why} they were never visited. \\

If we perform Dijkstra's algorithm on the original weight matrix and find the fastest route form node 13 to 52, we find this:

\begin{python}
print(Dijkst(12,51,weight_matrix))
\end{python}

\includegraphics{normalpath}

note that these are the python indices and not the actual node numbers.

If we look at the diagram, this means without taking the effect of congestion, the fastest path throughout the city is almost completely at the bottom of the map, by the river. Such as $40 \to 50 \to 51$. This means that it is unlikely for a car to need to travel through the upper west side of the city, such as through nodes 1,3,5 and 2. The only way the shortest path for a car could include such nodes is if the rest of the city is \textit{so} congested that the shortest path will indeed require these upper left nodes. We can see that edges like [3,2], [8,9] are not optimal for this reason, and are thus unused.

However for the vast majority of unused edges, it is intuitively clear that the reason they are included is because they are pointing completely away from the direction towards node 52. For example, I have highlighted edges $4 \to 1$, $12 \to 4$ and $52 \to 58$ in the diagram below.

\includegraphics[scale=0.6]{drawngraph}
 
These edges in particular are not only in the wrong in the x direction, but wrong in the y direction too. I have created the function below to count how many of these unused edges are pointing \textit{completely} in the wrong direction






\end{document}
